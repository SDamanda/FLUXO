/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/csv-parser";
exports.ids = ["vendor-chunks/csv-parser"];
exports.modules = {

/***/ "(rsc)/./node_modules/csv-parser/index.js":
/*!******************************************!*\
  !*** ./node_modules/csv-parser/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { Transform } = __webpack_require__(/*! stream */ \"stream\")\n\nconst [cr] = Buffer.from('\\r')\nconst [nl] = Buffer.from('\\n')\nconst defaults = {\n  escape: '\"',\n  headers: null,\n  mapHeaders: ({ header }) => header,\n  mapValues: ({ value }) => value,\n  newline: '\\n',\n  quote: '\"',\n  raw: false,\n  separator: ',',\n  skipComments: false,\n  skipLines: null,\n  maxRowBytes: Number.MAX_SAFE_INTEGER,\n  strict: false,\n  outputByteOffset: false\n}\n\nclass CsvParser extends Transform {\n  constructor (opts = {}) {\n    super({ objectMode: true, highWaterMark: 16 })\n\n    if (Array.isArray(opts)) opts = { headers: opts }\n\n    const options = Object.assign({}, defaults, opts)\n\n    options.customNewline = options.newline !== defaults.newline\n\n    for (const key of ['newline', 'quote', 'separator']) {\n      if (typeof options[key] !== 'undefined') {\n        ([options[key]] = Buffer.from(options[key]))\n      }\n    }\n\n    // if escape is not defined on the passed options, use the end value of quote\n    options.escape = (opts || {}).escape ? Buffer.from(options.escape)[0] : options.quote\n\n    this.state = {\n      empty: options.raw ? Buffer.alloc(0) : '',\n      escaped: false,\n      first: true,\n      lineNumber: 0,\n      previousEnd: 0,\n      rowLength: 0,\n      quoted: false\n    }\n\n    this._prev = null\n\n    if (options.headers === false) {\n      // enforce, as the column length check will fail if headers:false\n      options.strict = false\n    }\n\n    if (options.headers || options.headers === false) {\n      this.state.first = false\n    }\n\n    this.options = options\n    this.headers = options.headers\n    this.bytesRead = 0\n  }\n\n  parseCell (buffer, start, end) {\n    const { escape, quote } = this.options\n    // remove quotes from quoted cells\n    if (buffer[start] === quote && buffer[end - 1] === quote) {\n      start++\n      end--\n    }\n\n    let y = start\n\n    for (let i = start; i < end; i++) {\n      // check for escape characters and skip them\n      if (buffer[i] === escape && i + 1 < end && buffer[i + 1] === quote) {\n        i++\n      }\n\n      if (y !== i) {\n        buffer[y] = buffer[i]\n      }\n      y++\n    }\n\n    return this.parseValue(buffer, start, y)\n  }\n\n  parseLine (buffer, start, end) {\n    const { customNewline, escape, mapHeaders, mapValues, quote, separator, skipComments, skipLines } = this.options\n\n    end-- // trim newline\n    if (!customNewline && buffer.length && buffer[end - 1] === cr) {\n      end--\n    }\n\n    const comma = separator\n    const cells = []\n    let isQuoted = false\n    let offset = start\n\n    if (skipComments) {\n      const char = typeof skipComments === 'string' ? skipComments : '#'\n      if (buffer[start] === Buffer.from(char)[0]) {\n        return\n      }\n    }\n\n    const mapValue = (value) => {\n      if (this.state.first) {\n        return value\n      }\n\n      const index = cells.length\n      const header = this.headers[index]\n\n      return mapValues({ header, index, value })\n    }\n\n    for (let i = start; i < end; i++) {\n      const isStartingQuote = !isQuoted && buffer[i] === quote\n      const isEndingQuote = isQuoted && buffer[i] === quote && i + 1 <= end && buffer[i + 1] === comma\n      const isEscape = isQuoted && buffer[i] === escape && i + 1 < end && buffer[i + 1] === quote\n\n      if (isStartingQuote || isEndingQuote) {\n        isQuoted = !isQuoted\n        continue\n      } else if (isEscape) {\n        i++\n        continue\n      }\n\n      if (buffer[i] === comma && !isQuoted) {\n        let value = this.parseCell(buffer, offset, i)\n        value = mapValue(value)\n        cells.push(value)\n        offset = i + 1\n      }\n    }\n\n    if (offset < end) {\n      let value = this.parseCell(buffer, offset, end)\n      value = mapValue(value)\n      cells.push(value)\n    }\n\n    if (buffer[end - 1] === comma) {\n      cells.push(mapValue(this.state.empty))\n    }\n\n    const skip = skipLines && skipLines > this.state.lineNumber\n    this.state.lineNumber++\n\n    if (this.state.first && !skip) {\n      this.state.first = false\n      this.headers = cells.map((header, index) => mapHeaders({ header, index }))\n\n      this.emit('headers', this.headers)\n      return\n    }\n\n    if (!skip && this.options.strict && cells.length !== this.headers.length) {\n      const e = new RangeError('Row length does not match headers')\n      this.emit('error', e)\n    } else {\n      if (!skip) {\n        const byteOffset = this.bytesRead - buffer.length + start\n        this.writeRow(cells, byteOffset)\n      }\n    }\n  }\n\n  parseValue (buffer, start, end) {\n    if (this.options.raw) {\n      return buffer.slice(start, end)\n    }\n\n    return buffer.toString('utf-8', start, end)\n  }\n\n  writeRow (cells, byteOffset) {\n    const headers = (this.headers === false) ? cells.map((value, index) => index) : this.headers\n\n    const row = cells.reduce((o, cell, index) => {\n      const header = headers[index]\n      if (header === null) return o // skip columns\n      if (header !== undefined) {\n        o[header] = cell\n      } else {\n        o[`_${index}`] = cell\n      }\n      return o\n    }, {})\n\n    if (this.options.outputByteOffset) {\n      this.push({ row, byteOffset })\n    } else {\n      this.push(row)\n    }\n  }\n\n  _flush (cb) {\n    if (this.state.escaped || !this._prev) return cb()\n    this.parseLine(this._prev, this.state.previousEnd, this._prev.length + 1) // plus since online -1s\n    cb()\n  }\n\n  _transform (data, enc, cb) {\n    if (typeof data === 'string') {\n      data = Buffer.from(data)\n    }\n\n    const { escape, quote } = this.options\n    let start = 0\n    let buffer = data\n    this.bytesRead += data.byteLength\n\n    if (this._prev) {\n      start = this._prev.length\n      buffer = Buffer.concat([this._prev, data])\n      this._prev = null\n    }\n\n    const bufferLength = buffer.length\n\n    for (let i = start; i < bufferLength; i++) {\n      const chr = buffer[i]\n      const nextChr = i + 1 < bufferLength ? buffer[i + 1] : null\n\n      this.state.rowLength++\n      if (this.state.rowLength > this.options.maxRowBytes) {\n        return cb(new Error('Row exceeds the maximum size'))\n      }\n\n      if (!this.state.escaped && chr === escape && nextChr === quote && i !== start) {\n        this.state.escaped = true\n        continue\n      } else if (chr === quote) {\n        if (this.state.escaped) {\n          this.state.escaped = false\n          // non-escaped quote (quoting the cell)\n        } else {\n          this.state.quoted = !this.state.quoted\n        }\n        continue\n      }\n\n      if (!this.state.quoted) {\n        if (this.state.first && !this.options.customNewline) {\n          if (chr === nl) {\n            this.options.newline = nl\n          } else if (chr === cr) {\n            if (nextChr !== nl) {\n              this.options.newline = cr\n            }\n          }\n        }\n\n        if (chr === this.options.newline) {\n          this.parseLine(buffer, this.state.previousEnd, i + 1)\n          this.state.previousEnd = i + 1\n          this.state.rowLength = 0\n        }\n      }\n    }\n\n    if (this.state.previousEnd === bufferLength) {\n      this.state.previousEnd = 0\n      return cb()\n    }\n\n    if (bufferLength - this.state.previousEnd < data.length) {\n      this._prev = data\n      this.state.previousEnd -= (bufferLength - data.length)\n      return cb()\n    }\n\n    this._prev = buffer\n    cb()\n  }\n}\n\nmodule.exports = (opts) => new CsvParser(opts)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY3N2LXBhcnNlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLHNCQUFROztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEIsWUFBWSxxQ0FBcUM7O0FBRWpELHNDQUFzQzs7QUFFdEMsb0NBQW9DOztBQUVwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLDBGQUEwRjs7QUFFdEc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUJBQXlCLHNCQUFzQjtBQUMvQzs7QUFFQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrREFBK0QsZUFBZTs7QUFFOUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQSxLQUFLLElBQUk7O0FBRVQ7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcSmhvbiBNYW1hZGVpcm9zXFxEb2N1bWVudHNcXEdpdEh1YlxcRkxVWE9cXG5vZGVfbW9kdWxlc1xcY3N2LXBhcnNlclxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBUcmFuc2Zvcm0gfSA9IHJlcXVpcmUoJ3N0cmVhbScpXG5cbmNvbnN0IFtjcl0gPSBCdWZmZXIuZnJvbSgnXFxyJylcbmNvbnN0IFtubF0gPSBCdWZmZXIuZnJvbSgnXFxuJylcbmNvbnN0IGRlZmF1bHRzID0ge1xuICBlc2NhcGU6ICdcIicsXG4gIGhlYWRlcnM6IG51bGwsXG4gIG1hcEhlYWRlcnM6ICh7IGhlYWRlciB9KSA9PiBoZWFkZXIsXG4gIG1hcFZhbHVlczogKHsgdmFsdWUgfSkgPT4gdmFsdWUsXG4gIG5ld2xpbmU6ICdcXG4nLFxuICBxdW90ZTogJ1wiJyxcbiAgcmF3OiBmYWxzZSxcbiAgc2VwYXJhdG9yOiAnLCcsXG4gIHNraXBDb21tZW50czogZmFsc2UsXG4gIHNraXBMaW5lczogbnVsbCxcbiAgbWF4Um93Qnl0ZXM6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICBzdHJpY3Q6IGZhbHNlLFxuICBvdXRwdXRCeXRlT2Zmc2V0OiBmYWxzZVxufVxuXG5jbGFzcyBDc3ZQYXJzZXIgZXh0ZW5kcyBUcmFuc2Zvcm0ge1xuICBjb25zdHJ1Y3RvciAob3B0cyA9IHt9KSB7XG4gICAgc3VwZXIoeyBvYmplY3RNb2RlOiB0cnVlLCBoaWdoV2F0ZXJNYXJrOiAxNiB9KVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0cykpIG9wdHMgPSB7IGhlYWRlcnM6IG9wdHMgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLCBvcHRzKVxuXG4gICAgb3B0aW9ucy5jdXN0b21OZXdsaW5lID0gb3B0aW9ucy5uZXdsaW5lICE9PSBkZWZhdWx0cy5uZXdsaW5lXG5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBbJ25ld2xpbmUnLCAncXVvdGUnLCAnc2VwYXJhdG9yJ10pIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uc1trZXldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAoW29wdGlvbnNba2V5XV0gPSBCdWZmZXIuZnJvbShvcHRpb25zW2tleV0pKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIGVzY2FwZSBpcyBub3QgZGVmaW5lZCBvbiB0aGUgcGFzc2VkIG9wdGlvbnMsIHVzZSB0aGUgZW5kIHZhbHVlIG9mIHF1b3RlXG4gICAgb3B0aW9ucy5lc2NhcGUgPSAob3B0cyB8fCB7fSkuZXNjYXBlID8gQnVmZmVyLmZyb20ob3B0aW9ucy5lc2NhcGUpWzBdIDogb3B0aW9ucy5xdW90ZVxuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGVtcHR5OiBvcHRpb25zLnJhdyA/IEJ1ZmZlci5hbGxvYygwKSA6ICcnLFxuICAgICAgZXNjYXBlZDogZmFsc2UsXG4gICAgICBmaXJzdDogdHJ1ZSxcbiAgICAgIGxpbmVOdW1iZXI6IDAsXG4gICAgICBwcmV2aW91c0VuZDogMCxcbiAgICAgIHJvd0xlbmd0aDogMCxcbiAgICAgIHF1b3RlZDogZmFsc2VcbiAgICB9XG5cbiAgICB0aGlzLl9wcmV2ID0gbnVsbFxuXG4gICAgaWYgKG9wdGlvbnMuaGVhZGVycyA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIGVuZm9yY2UsIGFzIHRoZSBjb2x1bW4gbGVuZ3RoIGNoZWNrIHdpbGwgZmFpbCBpZiBoZWFkZXJzOmZhbHNlXG4gICAgICBvcHRpb25zLnN0cmljdCA9IGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaGVhZGVycyB8fCBvcHRpb25zLmhlYWRlcnMgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLnN0YXRlLmZpcnN0ID0gZmFsc2VcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gICAgdGhpcy5oZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzXG4gICAgdGhpcy5ieXRlc1JlYWQgPSAwXG4gIH1cblxuICBwYXJzZUNlbGwgKGJ1ZmZlciwgc3RhcnQsIGVuZCkge1xuICAgIGNvbnN0IHsgZXNjYXBlLCBxdW90ZSB9ID0gdGhpcy5vcHRpb25zXG4gICAgLy8gcmVtb3ZlIHF1b3RlcyBmcm9tIHF1b3RlZCBjZWxsc1xuICAgIGlmIChidWZmZXJbc3RhcnRdID09PSBxdW90ZSAmJiBidWZmZXJbZW5kIC0gMV0gPT09IHF1b3RlKSB7XG4gICAgICBzdGFydCsrXG4gICAgICBlbmQtLVxuICAgIH1cblxuICAgIGxldCB5ID0gc3RhcnRcblxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAvLyBjaGVjayBmb3IgZXNjYXBlIGNoYXJhY3RlcnMgYW5kIHNraXAgdGhlbVxuICAgICAgaWYgKGJ1ZmZlcltpXSA9PT0gZXNjYXBlICYmIGkgKyAxIDwgZW5kICYmIGJ1ZmZlcltpICsgMV0gPT09IHF1b3RlKSB7XG4gICAgICAgIGkrK1xuICAgICAgfVxuXG4gICAgICBpZiAoeSAhPT0gaSkge1xuICAgICAgICBidWZmZXJbeV0gPSBidWZmZXJbaV1cbiAgICAgIH1cbiAgICAgIHkrK1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBhcnNlVmFsdWUoYnVmZmVyLCBzdGFydCwgeSlcbiAgfVxuXG4gIHBhcnNlTGluZSAoYnVmZmVyLCBzdGFydCwgZW5kKSB7XG4gICAgY29uc3QgeyBjdXN0b21OZXdsaW5lLCBlc2NhcGUsIG1hcEhlYWRlcnMsIG1hcFZhbHVlcywgcXVvdGUsIHNlcGFyYXRvciwgc2tpcENvbW1lbnRzLCBza2lwTGluZXMgfSA9IHRoaXMub3B0aW9uc1xuXG4gICAgZW5kLS0gLy8gdHJpbSBuZXdsaW5lXG4gICAgaWYgKCFjdXN0b21OZXdsaW5lICYmIGJ1ZmZlci5sZW5ndGggJiYgYnVmZmVyW2VuZCAtIDFdID09PSBjcikge1xuICAgICAgZW5kLS1cbiAgICB9XG5cbiAgICBjb25zdCBjb21tYSA9IHNlcGFyYXRvclxuICAgIGNvbnN0IGNlbGxzID0gW11cbiAgICBsZXQgaXNRdW90ZWQgPSBmYWxzZVxuICAgIGxldCBvZmZzZXQgPSBzdGFydFxuXG4gICAgaWYgKHNraXBDb21tZW50cykge1xuICAgICAgY29uc3QgY2hhciA9IHR5cGVvZiBza2lwQ29tbWVudHMgPT09ICdzdHJpbmcnID8gc2tpcENvbW1lbnRzIDogJyMnXG4gICAgICBpZiAoYnVmZmVyW3N0YXJ0XSA9PT0gQnVmZmVyLmZyb20oY2hhcilbMF0pIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbWFwVmFsdWUgPSAodmFsdWUpID0+IHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLmZpcnN0KSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgfVxuXG4gICAgICBjb25zdCBpbmRleCA9IGNlbGxzLmxlbmd0aFxuICAgICAgY29uc3QgaGVhZGVyID0gdGhpcy5oZWFkZXJzW2luZGV4XVxuXG4gICAgICByZXR1cm4gbWFwVmFsdWVzKHsgaGVhZGVyLCBpbmRleCwgdmFsdWUgfSlcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgY29uc3QgaXNTdGFydGluZ1F1b3RlID0gIWlzUXVvdGVkICYmIGJ1ZmZlcltpXSA9PT0gcXVvdGVcbiAgICAgIGNvbnN0IGlzRW5kaW5nUXVvdGUgPSBpc1F1b3RlZCAmJiBidWZmZXJbaV0gPT09IHF1b3RlICYmIGkgKyAxIDw9IGVuZCAmJiBidWZmZXJbaSArIDFdID09PSBjb21tYVxuICAgICAgY29uc3QgaXNFc2NhcGUgPSBpc1F1b3RlZCAmJiBidWZmZXJbaV0gPT09IGVzY2FwZSAmJiBpICsgMSA8IGVuZCAmJiBidWZmZXJbaSArIDFdID09PSBxdW90ZVxuXG4gICAgICBpZiAoaXNTdGFydGluZ1F1b3RlIHx8IGlzRW5kaW5nUXVvdGUpIHtcbiAgICAgICAgaXNRdW90ZWQgPSAhaXNRdW90ZWRcbiAgICAgICAgY29udGludWVcbiAgICAgIH0gZWxzZSBpZiAoaXNFc2NhcGUpIHtcbiAgICAgICAgaSsrXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChidWZmZXJbaV0gPT09IGNvbW1hICYmICFpc1F1b3RlZCkge1xuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLnBhcnNlQ2VsbChidWZmZXIsIG9mZnNldCwgaSlcbiAgICAgICAgdmFsdWUgPSBtYXBWYWx1ZSh2YWx1ZSlcbiAgICAgICAgY2VsbHMucHVzaCh2YWx1ZSlcbiAgICAgICAgb2Zmc2V0ID0gaSArIDFcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0IDwgZW5kKSB7XG4gICAgICBsZXQgdmFsdWUgPSB0aGlzLnBhcnNlQ2VsbChidWZmZXIsIG9mZnNldCwgZW5kKVxuICAgICAgdmFsdWUgPSBtYXBWYWx1ZSh2YWx1ZSlcbiAgICAgIGNlbGxzLnB1c2godmFsdWUpXG4gICAgfVxuXG4gICAgaWYgKGJ1ZmZlcltlbmQgLSAxXSA9PT0gY29tbWEpIHtcbiAgICAgIGNlbGxzLnB1c2gobWFwVmFsdWUodGhpcy5zdGF0ZS5lbXB0eSkpXG4gICAgfVxuXG4gICAgY29uc3Qgc2tpcCA9IHNraXBMaW5lcyAmJiBza2lwTGluZXMgPiB0aGlzLnN0YXRlLmxpbmVOdW1iZXJcbiAgICB0aGlzLnN0YXRlLmxpbmVOdW1iZXIrK1xuXG4gICAgaWYgKHRoaXMuc3RhdGUuZmlyc3QgJiYgIXNraXApIHtcbiAgICAgIHRoaXMuc3RhdGUuZmlyc3QgPSBmYWxzZVxuICAgICAgdGhpcy5oZWFkZXJzID0gY2VsbHMubWFwKChoZWFkZXIsIGluZGV4KSA9PiBtYXBIZWFkZXJzKHsgaGVhZGVyLCBpbmRleCB9KSlcblxuICAgICAgdGhpcy5lbWl0KCdoZWFkZXJzJywgdGhpcy5oZWFkZXJzKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCFza2lwICYmIHRoaXMub3B0aW9ucy5zdHJpY3QgJiYgY2VsbHMubGVuZ3RoICE9PSB0aGlzLmhlYWRlcnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBlID0gbmV3IFJhbmdlRXJyb3IoJ1JvdyBsZW5ndGggZG9lcyBub3QgbWF0Y2ggaGVhZGVycycpXG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZSlcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFza2lwKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSB0aGlzLmJ5dGVzUmVhZCAtIGJ1ZmZlci5sZW5ndGggKyBzdGFydFxuICAgICAgICB0aGlzLndyaXRlUm93KGNlbGxzLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHBhcnNlVmFsdWUgKGJ1ZmZlciwgc3RhcnQsIGVuZCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMucmF3KSB7XG4gICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKHN0YXJ0LCBlbmQpXG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZygndXRmLTgnLCBzdGFydCwgZW5kKVxuICB9XG5cbiAgd3JpdGVSb3cgKGNlbGxzLCBieXRlT2Zmc2V0KSB7XG4gICAgY29uc3QgaGVhZGVycyA9ICh0aGlzLmhlYWRlcnMgPT09IGZhbHNlKSA/IGNlbGxzLm1hcCgodmFsdWUsIGluZGV4KSA9PiBpbmRleCkgOiB0aGlzLmhlYWRlcnNcblxuICAgIGNvbnN0IHJvdyA9IGNlbGxzLnJlZHVjZSgobywgY2VsbCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGhlYWRlciA9IGhlYWRlcnNbaW5kZXhdXG4gICAgICBpZiAoaGVhZGVyID09PSBudWxsKSByZXR1cm4gbyAvLyBza2lwIGNvbHVtbnNcbiAgICAgIGlmIChoZWFkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvW2hlYWRlcl0gPSBjZWxsXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvW2BfJHtpbmRleH1gXSA9IGNlbGxcbiAgICAgIH1cbiAgICAgIHJldHVybiBvXG4gICAgfSwge30pXG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm91dHB1dEJ5dGVPZmZzZXQpIHtcbiAgICAgIHRoaXMucHVzaCh7IHJvdywgYnl0ZU9mZnNldCB9KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB1c2gocm93KVxuICAgIH1cbiAgfVxuXG4gIF9mbHVzaCAoY2IpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5lc2NhcGVkIHx8ICF0aGlzLl9wcmV2KSByZXR1cm4gY2IoKVxuICAgIHRoaXMucGFyc2VMaW5lKHRoaXMuX3ByZXYsIHRoaXMuc3RhdGUucHJldmlvdXNFbmQsIHRoaXMuX3ByZXYubGVuZ3RoICsgMSkgLy8gcGx1cyBzaW5jZSBvbmxpbmUgLTFzXG4gICAgY2IoKVxuICB9XG5cbiAgX3RyYW5zZm9ybSAoZGF0YSwgZW5jLCBjYikge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhKVxuICAgIH1cblxuICAgIGNvbnN0IHsgZXNjYXBlLCBxdW90ZSB9ID0gdGhpcy5vcHRpb25zXG4gICAgbGV0IHN0YXJ0ID0gMFxuICAgIGxldCBidWZmZXIgPSBkYXRhXG4gICAgdGhpcy5ieXRlc1JlYWQgKz0gZGF0YS5ieXRlTGVuZ3RoXG5cbiAgICBpZiAodGhpcy5fcHJldikge1xuICAgICAgc3RhcnQgPSB0aGlzLl9wcmV2Lmxlbmd0aFxuICAgICAgYnVmZmVyID0gQnVmZmVyLmNvbmNhdChbdGhpcy5fcHJldiwgZGF0YV0pXG4gICAgICB0aGlzLl9wcmV2ID0gbnVsbFxuICAgIH1cblxuICAgIGNvbnN0IGJ1ZmZlckxlbmd0aCA9IGJ1ZmZlci5sZW5ndGhcblxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGJ1ZmZlckxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaHIgPSBidWZmZXJbaV1cbiAgICAgIGNvbnN0IG5leHRDaHIgPSBpICsgMSA8IGJ1ZmZlckxlbmd0aCA/IGJ1ZmZlcltpICsgMV0gOiBudWxsXG5cbiAgICAgIHRoaXMuc3RhdGUucm93TGVuZ3RoKytcbiAgICAgIGlmICh0aGlzLnN0YXRlLnJvd0xlbmd0aCA+IHRoaXMub3B0aW9ucy5tYXhSb3dCeXRlcykge1xuICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdSb3cgZXhjZWVkcyB0aGUgbWF4aW11bSBzaXplJykpXG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5zdGF0ZS5lc2NhcGVkICYmIGNociA9PT0gZXNjYXBlICYmIG5leHRDaHIgPT09IHF1b3RlICYmIGkgIT09IHN0YXJ0KSB7XG4gICAgICAgIHRoaXMuc3RhdGUuZXNjYXBlZCA9IHRydWVcbiAgICAgICAgY29udGludWVcbiAgICAgIH0gZWxzZSBpZiAoY2hyID09PSBxdW90ZSkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5lc2NhcGVkKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZS5lc2NhcGVkID0gZmFsc2VcbiAgICAgICAgICAvLyBub24tZXNjYXBlZCBxdW90ZSAocXVvdGluZyB0aGUgY2VsbClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YXRlLnF1b3RlZCA9ICF0aGlzLnN0YXRlLnF1b3RlZFxuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5zdGF0ZS5xdW90ZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZmlyc3QgJiYgIXRoaXMub3B0aW9ucy5jdXN0b21OZXdsaW5lKSB7XG4gICAgICAgICAgaWYgKGNociA9PT0gbmwpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5uZXdsaW5lID0gbmxcbiAgICAgICAgICB9IGVsc2UgaWYgKGNociA9PT0gY3IpIHtcbiAgICAgICAgICAgIGlmIChuZXh0Q2hyICE9PSBubCkge1xuICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMubmV3bGluZSA9IGNyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNociA9PT0gdGhpcy5vcHRpb25zLm5ld2xpbmUpIHtcbiAgICAgICAgICB0aGlzLnBhcnNlTGluZShidWZmZXIsIHRoaXMuc3RhdGUucHJldmlvdXNFbmQsIGkgKyAxKVxuICAgICAgICAgIHRoaXMuc3RhdGUucHJldmlvdXNFbmQgPSBpICsgMVxuICAgICAgICAgIHRoaXMuc3RhdGUucm93TGVuZ3RoID0gMFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3RhdGUucHJldmlvdXNFbmQgPT09IGJ1ZmZlckxlbmd0aCkge1xuICAgICAgdGhpcy5zdGF0ZS5wcmV2aW91c0VuZCA9IDBcbiAgICAgIHJldHVybiBjYigpXG4gICAgfVxuXG4gICAgaWYgKGJ1ZmZlckxlbmd0aCAtIHRoaXMuc3RhdGUucHJldmlvdXNFbmQgPCBkYXRhLmxlbmd0aCkge1xuICAgICAgdGhpcy5fcHJldiA9IGRhdGFcbiAgICAgIHRoaXMuc3RhdGUucHJldmlvdXNFbmQgLT0gKGJ1ZmZlckxlbmd0aCAtIGRhdGEubGVuZ3RoKVxuICAgICAgcmV0dXJuIGNiKClcbiAgICB9XG5cbiAgICB0aGlzLl9wcmV2ID0gYnVmZmVyXG4gICAgY2IoKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gKG9wdHMpID0+IG5ldyBDc3ZQYXJzZXIob3B0cylcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/csv-parser/index.js\n");

/***/ })

};
;